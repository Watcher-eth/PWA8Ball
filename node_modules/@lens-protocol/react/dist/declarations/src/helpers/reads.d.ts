import { QueryResult as ApolloQueryResult, OperationVariables } from '@apollo/client';
import { UnspecifiedError, InputMaybe, Cursor, PaginatedResultInfo } from '@lens-protocol/api-bindings';
import { Prettify } from '@lens-protocol/shared-kernel';
/**
 * @deprecated use {@link ReadResult | `ReadResult<T, E>`} instead. Removal slated for v3.x.
 */
export type ReadResultWithoutError<T> = {
    data: undefined;
    loading: true;
} | {
    data: T;
    loading: false;
};
/**
 * @deprecated use {@link ReadResult | `ReadResult<T, E>`} instead. Removal slated for v3.x.
 */
export type ReadResultWithError<T, E> = ReadResult<T, E>;
/**
 * A discriminated union of the possible results of a read operation.
 *
 * You can rely on the `loading` value to determine if the `data` or `error` can be evaluated.
 *
 * If `error` is `undefined`, then `data` value will be available.
 */
export type ReadResult<T, E = UnspecifiedError> = {
    data: undefined;
    error: undefined;
    loading: true;
} | {
    data: T;
    error: undefined;
    loading: false;
} | {
    data: undefined;
    error: E;
    loading: false;
};
/**
 * A standardized query result data object.
 *
 * All queries should alias their results to `result` to ensure interoperability
 * with this helper hooks.
 *
 * @internal
 */
export type QueryData<R> = {
    result: R;
};
/**
 * @internal
 */
export declare function useReadResult<TResult, TVariables extends OperationVariables = {
    [key: string]: never;
}>({ error, data, }: ApolloQueryResult<QueryData<TResult>, TVariables>): ReadResult<TResult, UnspecifiedError>;
export type PaginatedArgs<T> = Prettify<Omit<T, 'cursor'>>;
/**
 * A paginated read result.
 */
export type PaginatedReadResult<T> = ReadResult<T, UnspecifiedError> & {
    /**
     * The number of items that are available before the results set.
     *
     * Use this to determine if you want to offer the option of loading more items
     * at the beginning of the list via the `prev` method.
     */
    beforeCount: number;
    /**
     * Whether there are more items to fetch in the next page
     */
    hasMore: boolean;
    /**
     * Fetches the next page of items.
     *
     * @returns A promise that resolves when the operation is complete, regardless if it had any items to fetch.
     */
    next: () => Promise<void>;
    /**
     * Fetches the previous page of items.
     *
     * @returns A promise that resolves when the operation is complete, regardless if it had any items to fetch.
     */
    prev: () => Promise<void>;
};
/**
 * @internal
 */
export type PaginatedQueryVariables = OperationVariables & {
    cursor?: InputMaybe<Cursor>;
};
/**
 * @internal
 */
export type PaginatedQueryData<TItem> = {
    result: {
        pageInfo: PaginatedResultInfo;
        items: TItem[];
    };
};
type InferPaginatedItemsType<TData extends PaginatedQueryData<unknown>> = TData extends PaginatedQueryData<infer TItem> ? TItem : never;
/**
 * @internal
 */
export declare function usePaginatedReadResult<TVariables extends PaginatedQueryVariables, TData extends PaginatedQueryData<TItem>, TItem = InferPaginatedItemsType<TData>>({ error, data, loading, fetchMore, variables, observable, }: ApolloQueryResult<TData, TVariables>): PaginatedReadResult<TItem[]>;
export {};
