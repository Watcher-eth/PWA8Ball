import { DocumentNode, OperationVariables, QueryHookOptions } from '@apollo/client';
import { PaginatedQueryData, QueryData, ReadResult, PaginatedReadResult } from "./reads.js";
/**
 * A read result that supports React Suspense and includes an error.
 *
 * @experimental This is an experimental type that can change at any time.
 */
export type SuspenseResultWithError<T, E> = {
    data: undefined;
    error: E;
} | {
    data: T;
    error: undefined;
};
/**
 * A read result that supports React Suspense
 *
 * @experimental This is an experimental type that can change at any time.
 */
export type SuspenseResult<T> = {
    data: T;
};
/**
 * @deprecated Use {@link SuspenseResult | `SuspenseResult`} instead.
 */
export type SuspenseReadResult<T, E = never> = SuspenseResultWithError<T, E>;
/**
 * Helper type to enable Suspense mode.
 *
 * @experimental This is an experimental type that can change at any time.
 */
export type SuspenseEnabled<T = {}> = T & {
    suspense: true;
};
/**
 * @internal
 */
export type UseSuspenseQueryArgs<TData, TVariables extends OperationVariables> = {
    suspense: true;
    query: DocumentNode;
    options: QueryHookOptions<TData, TVariables>;
};
/**
 * @internal
 */
export type UseQueryArgs<TData, TVariables extends OperationVariables> = {
    suspense: false;
    query: DocumentNode;
    options: QueryHookOptions<TData, TVariables>;
};
/**
 * @internal
 */
export type UseSuspendableQueryArgs<TData, TVariables extends OperationVariables> = UseSuspenseQueryArgs<TData, TVariables> | UseQueryArgs<TData, TVariables>;
/**
 * @internal
 */
export declare function useSuspendableQuery<TResult, TVariables extends OperationVariables>(args: UseSuspendableQueryArgs<QueryData<TResult>, TVariables>): ReadResult<TResult> | SuspenseResult<TResult>;
/**
 * A paginated read result that supports React Suspense.
 *
 * @experimental This is an experimental type that can change at any time.
 */
export type SuspensePaginatedResult<T> = SuspenseResult<T> & {
    /**
     * @deprecated not used with Suspense mode
     */
    beforeCount: number;
    /**
     * Whether there are more items to fetch in the next page
     */
    hasMore: boolean;
    /**
     * Fetches the next page of items.
     *
     * Calling this function will cause the component to re-suspend,
     * unless the call site is wrapped in [startTransition](https://react.dev/reference/react/startTransition).
     *
     * @returns A promise that resolves when the operation is complete, regardless if it had any items to fetch.
     */
    next: () => Promise<void>;
    /**
     * Fetches the previous page of items.
     *
     * Calling this function will cause the component to re-suspend,
     * unless the call site is wrapped in [startTransition](https://react.dev/reference/react/startTransition).
     *
     * @returns A promise that resolves when the operation is complete, regardless if it had any items to fetch.
     */
    prev: () => Promise<void>;
};
/**
 * A paginated read result that supports React Suspense.
 *
 * @experimental This is an experimental type that can change at any time.
 */
export type SuspendablePaginatedResult<T> = PaginatedReadResult<T> | SuspensePaginatedResult<T>;
/**
 * @internal
 */
export declare function useSuspendablePaginatedQuery<TItem, TVariables extends OperationVariables>(args: UseSuspendableQueryArgs<PaginatedQueryData<TItem>, TVariables>): PaginatedReadResult<TItem[]> | SuspensePaginatedResult<TItem[]>;
