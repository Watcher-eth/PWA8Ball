import { from, ApolloLink, HttpLink, makeVar, useReactiveVar } from '@apollo/client';
import { _ as _unsupportedIterableToArray, a as _objectSpread2, b as _inherits, c as _createSuper, d as _classCallCheck, e as _defineProperty, f as _assertThisInitialized, g as _createClass, h as _asyncToGenerator, i as _regeneratorRuntime, j as graphQLResultHasUnauthenticatedError, S as SafeApolloClient, k as createLensCache, l as createSnapshotCache } from './generated-6af17561.esm.js';
export { d6 as ActOnOpenActionDocument, eK as AddProfileInterestsDocument, gf as AddPublicationBookmarkDocument, gj as AddPublicationNotInterestedDocument, gn as AddReactionDocument, A as ApolloServerErrorCode, dP as ApprovedModuleAllowanceAmountDocument, dg as AuthAuthenticateDocument, da as AuthChallengeDocument, di as AuthRefreshDocument, dd as AuthVerifyDocument, eQ as BlockDocument, gU as BroadcastOnMomokaDocument, gS as BroadcastOnchainDocument, C as ChangeProfileManagerActionType, z as ClaimProfileStatusType, eI as ClaimProfileWithHandleDocument, B as ClaimProfileWithHandleErrorReasonType, eF as ClaimableProfilesDocument, D as CollectOpenActionModuleType, fY as CommentOnMomokaDocument, fQ as CommentOnchainDocument, E as CommentRankingFilterType, F as ComparisonOperatorConditionType, d8 as CreateActOnOpenActionTypedDataDocument, f2 as CreateBlockProfilesTypedDataDocument, f0 as CreateChangeProfileManagersTypedDataDocument, f6 as CreateFollowTypedDataDocument, g8 as CreateLegacyCollectTypedDataDocument, fi as CreateLinkHandleToProfileTypedDataDocument, fI as CreateMomokaCommentTypedDataDocument, fK as CreateMomokaMirrorTypedDataDocument, fG as CreateMomokaPostTypedDataDocument, fM as CreateMomokaQuoteTypedDataDocument, fA as CreateOnchainCommentTypedDataDocument, fC as CreateOnchainMirrorTypedDataDocument, fy as CreateOnchainPostTypedDataDocument, fE as CreateOnchainQuoteTypedDataDocument, e_ as CreateOnchainSetProfileMetadataTypedDataDocument, H as CreateProfileWithHandleErrorReasonType, fc as CreateSetFollowModuleTypedDataDocument, f4 as CreateUnblockProfilesTypedDataDocument, f8 as CreateUnfollowTypedDataDocument, fk as CreateUnlinkHandleFromProfileTypedDataDocument, dM as CurrenciesDocument, I as CustomFiltersType, J as DecryptFailReasonType, eY as DismissRecommendedProfilesDocument, ds as ExploreProfilesDocument, K as ExploreProfilesOrderByType, L as ExplorePublicationType, dp as ExplorePublicationsDocument, M as ExplorePublicationsOrderByType, dv as FeedDocument, N as FeedEventItemType, dy as FeedHighlightsDocument, eU as FollowDocument, O as FollowModuleType, gA as FollowRevenuesDocument, eq as FollowersDocument, en as FollowingDocument, cw as FragmentActedNotification, aN as FragmentAmount, ba as FragmentAndCondition, aD as FragmentApp, ch as FragmentApprovedAllowanceAmountResult, bs as FragmentArticleMetadataV3, bf as FragmentAudio, bp as FragmentAudioMetadataV3, aC as FragmentAuthChallengeResult, a$ as FragmentCanDecryptResponse, bx as FragmentCheckingInMetadataV3, cB as FragmentClaimProfileWithHandleErrorResult, cO as FragmentClaimableProfilesResult, b9 as FragmentCollectCondition, c1 as FragmentComment, b_ as FragmentCommentFields, co as FragmentCommentNotification, aB as FragmentCreateActOnOpenActionBroadcastItemResult, aA as FragmentCreateActOnOpenActionEip712TypedData, cF as FragmentCreateBlockProfilesBroadcastItemResult, cE as FragmentCreateChangeProfileManagersBroadcastItemResult, cH as FragmentCreateFollowBroadcastItemResult, c_ as FragmentCreateLegacyCollectBroadcastItemResult, cZ as FragmentCreateLegacyCollectEip712TypedData, cK as FragmentCreateLinkHandleToProfileBroadcastItemResult, cW as FragmentCreateMomokaCommentBroadcastItemResult, cX as FragmentCreateMomokaMirrorBroadcastItemResult, cV as FragmentCreateMomokaPostBroadcastItemResult, ca as FragmentCreateMomokaPublicationResult, cY as FragmentCreateMomokaQuoteBroadcastItemResult, cS as FragmentCreateOnchainCommentBroadcastItemResult, cT as FragmentCreateOnchainMirrorBroadcastItemResult, cR as FragmentCreateOnchainPostBroadcastItemResult, cU as FragmentCreateOnchainQuoteBroadcastItemResult, cD as FragmentCreateOnchainSetProfileMetadataBroadcastItemResult, cC as FragmentCreateProfileWithHandleErrorResult, cJ as FragmentCreateSetFollowModuleBroadcastItemResult, cG as FragmentCreateUnblockProfilesBroadcastItemResult, cI as FragmentCreateUnfollowBroadcastItemResult, cL as FragmentCreateUnlinkHandleFromProfileBroadcastItemResult, bV as FragmentDegreesOfSeparationReferenceModuleSettings, az as FragmentEip712TypedDataDomain, ay as FragmentEip712TypedDataField, bw as FragmentEmbedMetadataV3, be as FragmentEncryptableAudio, bg as FragmentEncryptableAudioSet, bh as FragmentEncryptableImage, bi as FragmentEncryptableImageSet, bk as FragmentEncryptableVideo, bm as FragmentEncryptableVideoSet, b6 as FragmentEoaOwnershipCondition, aK as FragmentErc20, b5 as FragmentErc20OwnershipCondition, bu as FragmentEventMetadataV3, c0 as FragmentExplorePublication, aO as FragmentFeeFollowModuleSettings, c5 as FragmentFeedHighlight, c4 as FragmentFeedItem, aL as FragmentFiat, aM as FragmentFiatAmount, b8 as FragmentFollowCondition, cx as FragmentFollowNotification, bU as FragmentFollowOnlyReferenceModuleSettings, ci as FragmentGenerateModuleCurrencyApprovalResult, bt as FragmentGeoLocation, aX as FragmentHandleInfo, aR as FragmentImage, br as FragmentImageMetadataV3, b2 as FragmentImageSet, cb as FragmentImageTransformParam, cc as FragmentInjectCommonQueryParams, cd as FragmentInvitedResult, cs as FragmentKnownCollectOpenActionResult, cf as FragmentKnownSupportedModule, bQ as FragmentLegacyAaveFeeCollectModuleSettings, bP as FragmentLegacyErc4626FeeCollectModuleSettings, bH as FragmentLegacyFeeCollectModuleSettings, bG as FragmentLegacyFreeCollectModuleSettings, bI as FragmentLegacyLimitedFeeCollectModuleSettings, bJ as FragmentLegacyLimitedTimedFeeCollectModuleSettings, bN as FragmentLegacyMultirecipientFeeCollectModuleSettings, bK as FragmentLegacyRevertCollectModuleSettings, bO as FragmentLegacySimpleCollectModuleSettings, bL as FragmentLegacyTimedFeeCollectModuleSettings, c9 as FragmentLensProfileManagerRelayError, d3 as FragmentLensTransactionResult, bv as FragmentLinkMetadataV3, bF as FragmentLiveStreamMetadataV3, b3 as FragmentMarketplaceMetadata, cy as FragmentMentionNotification, bD as FragmentMintMetadataV3, c2 as FragmentMirror, cq as FragmentMirrorNotification, ce as FragmentModuleInfo, cj as FragmentModuleMetadata, ck as FragmentModuleMetadataResult, aE as FragmentMomokaInfo, bR as FragmentMultirecipientFeeCollectOpenActionSettings, aF as FragmentNetworkAddress, aT as FragmentNftImage, b4 as FragmentNftOwnershipCondition, cz as FragmentNotification, cv as FragmentOpenActionProfileActed, cu as FragmentOpenActionResult, aG as FragmentOptimisticStatusResult, bb as FragmentOrCondition, c6 as FragmentPaginatedResultInfo, bY as FragmentPost, a_ as FragmentProfile, cM as FragmentProfileActionHistory, aV as FragmentProfileCoverSet, aZ as FragmentProfileFields, aI as FragmentProfileGuardianResult, cA as FragmentProfileManager, aW as FragmentProfileMetadata, cp as FragmentProfileMirrorResult, aJ as FragmentProfileOnchainIdentity, aH as FragmentProfileOperations, b7 as FragmentProfileOwnershipCondition, aU as FragmentProfilePicture, aS as FragmentProfilePictureSet, cm as FragmentProfileReactedResult, c$ as FragmentProfileReactionResult, aY as FragmentProfileStats, d0 as FragmentProfileWhoReactedResult, b1 as FragmentPublicationMarketplaceMetadataAttribute, bd as FragmentPublicationMetadataLitEncryption, bj as FragmentPublicationMetadataMediaAudio, bo as FragmentPublicationMetadataMediaImage, bn as FragmentPublicationMetadataMediaVideo, b0 as FragmentPublicationOperations, d2 as FragmentPublicationRevenue, bX as FragmentPublicationStats, cQ as FragmentPublicationValidateMetadataResult, b$ as FragmentQuote, bZ as FragmentQuoteFields, cr as FragmentQuoteNotification, cl as FragmentReactedResult, c3 as FragmentReactionEvent, cn as FragmentReactionNotification, bM as FragmentRecipient, c8 as FragmentRelayError, d4 as FragmentRelayQueueResult, c7 as FragmentRelaySuccess, cN as FragmentReservedClaimable, d1 as FragmentRevenueAggregate, aP as FragmentRevertFollowModuleSettings, bc as FragmentRootCondition, bS as FragmentSimpleCollectOpenActionSettings, bE as FragmentSpaceMetadataV3, bB as FragmentStoryMetadataV3, cP as FragmentTagResult, by as FragmentTextOnlyMetadataV3, bA as FragmentThreeDMetadataV3, bz as FragmentThreeDMetadataV3Asset, bC as FragmentTransactionMetadataV3, aQ as FragmentUnknownFollowModuleSettings, bT as FragmentUnknownOpenActionModuleSettings, ct as FragmentUnknownOpenActionResult, bW as FragmentUnknownReferenceModuleSettings, cg as FragmentUnknownSupportedModule, d5 as FragmentUserSigNonces, bl as FragmentVideo, bq as FragmentVideoMetadataV3, dS as GenerateModuleCurrencyApprovalDataDocument, G as GetSnapshotProposalDocument, dB as HandleToAddressDocument, g2 as HidePublicationDocument, P as IdKitPhoneVerifyWebhookResultStatusType, dK as InviteDocument, dE as InvitedProfilesDocument, h3 as LastLoggedInProfileDocument, g6 as LegacyCollectDocument, Q as LensProfileManagerRelayErrorReasonType, R as LensProtocolVersion, W as LensTransactionFailureType, gP as LensTransactionStatusDocument, X as LensTransactionStatusType, Y as LimitType, fe as LinkHandleToProfileDocument, Z as MarketplaceMetadataAttributeDisplayType, $ as MetadataAttributeType, f_ as MirrorOnMomokaDocument, fS as MirrorOnchainDocument, e5 as ModuleMetadataDocument, a0 as ModuleType, a1 as MomokaValidatorError, et as MutualFollowersDocument, a2 as NftCollectionOwnersOrder, a3 as NftContractType, a4 as NotificationType, e8 as NotificationsDocument, a5 as OpenActionCategoryType, a6 as OpenActionModuleType, gW as OwnedHandlesDocument, a7 as PoapTokenLayerType, a8 as PopularNftCollectionsOrder, fW as PostOnMomokaDocument, fO as PostOnchainDocument, eC as ProfileActionHistoryDocument, a9 as ProfileActionHistoryType, dH as ProfileAlreadyInvitedDocument, eb as ProfileDocument, aa as ProfileInterestTypes, eh as ProfileManagersDocument, ek as ProfileRecommendationsDocument, ab as ProfileReportingFraudSubreason, ac as ProfileReportingReason, ad as ProfileReportingSpamSubreason, ee as ProfilesDocument, gZ as ProfilesManagedDocument, gc as PublicationBookmarksDocument, ae as PublicationContentWarningType, fm as PublicationDocument, af as PublicationMetadataLicenseType, ag as PublicationMetadataMainFocusType, ah as PublicationMetadataTransactionType, ai as PublicationReactionType, aj as PublicationReportingFraudSubreason, ak as PublicationReportingIllegalSubreason, al as PublicationReportingReason, am as PublicationReportingSensitiveSubreason, an as PublicationReportingSpamSubreason, ao as PublicationType, fp as PublicationsDocument, fs as PublicationsTagsDocument, g0 as QuoteOnMomokaDocument, fU as QuoteOnchainDocument, ap as ReferenceModuleType, ga as RefreshPublicationMetadataDocument, aq as RefreshPublicationMetadataResultType, ar as RelayErrorReasonType, gM as RelayQueuesDocument, as as RelayRoleKey, eM as RemoveProfileInterestsDocument, gh as RemovePublicationBookmarkDocument, gp as RemoveReactionDocument, g4 as ReportPublicationDocument, gx as RevenueFromPublicationDocument, gu as RevenueFromPublicationsDocument, dm as RevokeAuthenticationDocument, gG as SearchProfilesDocument, at as SearchPublicationType, gD as SearchPublicationsDocument, fa as SetFollowModuleDocument, eO as SetProfileMetadataDocument, au as SupportedFiatType, dV as SupportedFollowModulesDocument, e2 as SupportedOpenActionCollectModulesDocument, d$ as SupportedOpenActionModulesDocument, dY as SupportedReferenceModulesDocument, av as TagSortCriteriaType, aw as TriStateValue, gJ as TxIdToTxHashDocument, T as TxStatus, eS as UnblockDocument, gl as UndoPublicationNotInterestedDocument, eW as UnfollowDocument, fg as UnlinkHandleFromProfileDocument, U as UnspecifiedError, h0 as UserSigNoncesDocument, fv as ValidatePublicationMetadataDocument, V as ValidationError, dk as WalletAuthenticationToProfileAuthenticationDocument, ew as WhoActedOnPublicationDocument, ez as WhoHaveBlockedDocument, gr as WhoReactedPublicationDocument, ax as WorldcoinPhoneVerifyType, q as countAnyPendingCollect, p as countAnyPendingCollectFor, v as countPendingFollowFor, w as countPendingUnfollowFor, m as defaultQueryParams, x as getPendingLinkHandleTxFor, y as getPendingUnlinkHandleTxFor, j as graphQLResultHasUnauthenticatedError, t as hasPendingBlockForProfile, s as hasPendingUnblockForProfile, h6 as isCursor, n as isValidationApolloError, r as recentTransactionsVar, d7 as useActOnOpenAction, eL as useAddProfileInterests, gg as useAddPublicationBookmark, gk as useAddPublicationNotInterested, go as useAddReaction, dQ as useApprovedModuleAllowanceAmount, dR as useApprovedModuleAllowanceAmountLazyQuery, dh as useAuthAuthenticate, db as useAuthChallenge, dc as useAuthChallengeLazyQuery, dj as useAuthRefresh, de as useAuthVerify, df as useAuthVerifyLazyQuery, eR as useBlock, gV as useBroadcastOnMomoka, gT as useBroadcastOnchain, eJ as useClaimProfileWithHandle, eG as useClaimableProfiles, eH as useClaimableProfilesLazyQuery, fZ as useCommentOnMomoka, fR as useCommentOnchain, d9 as useCreateActOnOpenActionTypedData, f3 as useCreateBlockProfilesTypedData, f1 as useCreateChangeProfileManagersTypedData, f7 as useCreateFollowTypedData, g9 as useCreateLegacyCollectTypedData, fj as useCreateLinkHandleToProfileTypedData, fJ as useCreateMomokaCommentTypedData, fL as useCreateMomokaMirrorTypedData, fH as useCreateMomokaPostTypedData, fN as useCreateMomokaQuoteTypedData, fB as useCreateOnchainCommentTypedData, fD as useCreateOnchainMirrorTypedData, fz as useCreateOnchainPostTypedData, fF as useCreateOnchainQuoteTypedData, e$ as useCreateOnchainSetProfileMetadataTypedData, fd as useCreateSetFollowModuleTypedData, f5 as useCreateUnblockProfilesTypedData, f9 as useCreateUnfollowTypedData, fl as useCreateUnlinkHandleFromProfileTypedData, dN as useCurrencies, dO as useCurrenciesLazyQuery, eZ as useDismissRecommendedProfiles, dt as useExploreProfiles, du as useExploreProfilesLazyQuery, dq as useExplorePublications, dr as useExplorePublicationsLazyQuery, dw as useFeed, dz as useFeedHighlights, dA as useFeedHighlightsLazyQuery, dx as useFeedLazyQuery, eV as useFollow, gB as useFollowRevenues, gC as useFollowRevenuesLazyQuery, er as useFollowers, es as useFollowersLazyQuery, eo as useFollowing, ep as useFollowingLazyQuery, dT as useGenerateModuleCurrencyApprovalData, dU as useGenerateModuleCurrencyApprovalDataLazyQuery, u as useGetSnapshotProposal, dC as useHandleToAddress, dD as useHandleToAddressLazyQuery, g3 as useHidePublication, dL as useInvite, dF as useInvitedProfiles, dG as useInvitedProfilesLazyQuery, h4 as useLastLoggedInProfile, h5 as useLastLoggedInProfileLazyQuery, g7 as useLegacyCollect, gQ as useLensTransactionStatus, gR as useLensTransactionStatusLazyQuery, ff as useLinkHandleToProfile, f$ as useMirrorOnMomoka, fT as useMirrorOnchain, e6 as useModuleMetadata, e7 as useModuleMetadataLazyQuery, eu as useMutualFollowers, ev as useMutualFollowersLazyQuery, e9 as useNotifications, ea as useNotificationsLazyQuery, gX as useOwnedHandles, gY as useOwnedHandlesLazyQuery, fX as usePostOnMomoka, fP as usePostOnchain, ec as useProfile, eD as useProfileActionHistory, eE as useProfileActionHistoryLazyQuery, dI as useProfileAlreadyInvited, dJ as useProfileAlreadyInvitedLazyQuery, ed as useProfileLazyQuery, ei as useProfileManagers, ej as useProfileManagersLazyQuery, el as useProfileRecommendations, em as useProfileRecommendationsLazyQuery, ef as useProfiles, eg as useProfilesLazyQuery, g_ as useProfilesManaged, g$ as useProfilesManagedLazyQuery, fn as usePublication, gd as usePublicationBookmarks, ge as usePublicationBookmarksLazyQuery, fo as usePublicationLazyQuery, fq as usePublications, fr as usePublicationsLazyQuery, ft as usePublicationsTags, fu as usePublicationsTagsLazyQuery, g1 as useQuoteOnMomoka, fV as useQuoteOnchain, o as useRecentTransactionsVar, gb as useRefreshPublicationMetadata, gN as useRelayQueues, gO as useRelayQueuesLazyQuery, eN as useRemoveProfileInterests, gi as useRemovePublicationBookmark, gq as useRemoveReaction, g5 as useReportPublication, gy as useRevenueFromPublication, gz as useRevenueFromPublicationLazyQuery, gv as useRevenueFromPublications, gw as useRevenueFromPublicationsLazyQuery, dn as useRevokeAuthentication, gH as useSearchProfiles, gI as useSearchProfilesLazyQuery, gE as useSearchPublications, gF as useSearchPublicationsLazyQuery, fb as useSetFollowModule, eP as useSetProfileMetadata, dW as useSupportedFollowModules, dX as useSupportedFollowModulesLazyQuery, e3 as useSupportedOpenActionCollectModules, e4 as useSupportedOpenActionCollectModulesLazyQuery, e0 as useSupportedOpenActionModules, e1 as useSupportedOpenActionModulesLazyQuery, dZ as useSupportedReferenceModules, d_ as useSupportedReferenceModulesLazyQuery, gK as useTxIdToTxHash, gL as useTxIdToTxHashLazyQuery, eT as useUnblock, gm as useUndoPublicationNotInterested, eX as useUnfollow, fh as useUnlinkHandleFromProfile, h1 as useUserSigNonces, h2 as useUserSigNoncesLazyQuery, fw as useValidatePublicationMetadata, fx as useValidatePublicationMetadataLazyQuery, dl as useWalletAuthenticationToProfileAuthentication, ex as useWhoActedOnPublication, ey as useWhoActedOnPublicationLazyQuery, eA as useWhoHaveBlocked, eB as useWhoHaveBlockedLazyQuery, gs as useWhoReactedPublication, gt as useWhoReactedPublicationLazyQuery } from './generated-6af17561.esm.js';
import { setContext } from '@apollo/client/link/context';
import { Observable, maybe } from '@apollo/client/utilities';
import { ChainType, erc20, Amount, omitDeep, invariant, never, assertNever } from '@lens-protocol/shared-kernel';
import { TransactionKind } from '@lens-protocol/domain/entities';
import { AllOpenActionType } from '@lens-protocol/domain/use-cases/publications';
import { FollowPolicyType } from '@lens-protocol/domain/use-cases/profile';

function semVer(value) {
  // for now just asserts the type, in future it will enforce a format
  return value;
}

var LENS_API_MINIMAL_SUPPORTED_VERSION = semVer('2.0.0');

function chainType(chainId) {
  switch (chainId) {
    case 1:
    case 5:
      return ChainType.ETHEREUM;
    case 137:
    case 80001:
      return ChainType.POLYGON;
    default:
      throw new Error("Not supported chainId: ".concat(chainId));
  }
}
function erc20Amount(_ref) {
  var from = _ref.from;
  var asset = from.asset,
    value = from.value;
  var erc20Asset = erc20({
    name: asset.name,
    decimals: asset.decimals,
    symbol: asset.symbol,
    address: asset.contract.address,
    chainType: chainType(asset.contract.chainId)
  });
  return Amount.erc20(erc20Asset, value);
}

var validationRegex = /^[a-z](?:[a-z0-9_]{4,25})$/;

/**
 * @group Helpers
 */
function isValidHandle(handle) {
  return validationRegex.test(handle);
}

function omitTypename(target) {
  return omitDeep(target, '__typename');
}

var ModulesWithKnownCollectCapability = {
  LegacyAaveFeeCollectModuleSettings: true,
  LegacyERC4626FeeCollectModuleSettings: true,
  LegacyFeeCollectModuleSettings: true,
  LegacyLimitedFeeCollectModuleSettings: true,
  LegacyLimitedTimedFeeCollectModuleSettings: true,
  LegacyMultirecipientFeeCollectModuleSettings: true,
  LegacyTimedFeeCollectModuleSettings: true,
  LegacySimpleCollectModuleSettings: true,
  LegacyFreeCollectModuleSettings: true,
  MultirecipientFeeCollectOpenActionSettings: true,
  SimpleCollectOpenActionSettings: true,
  LegacyRevertCollectModuleSettings: false,
  UnknownOpenActionModuleSettings: false
};
function isKnownCollectModuleSettings(settings) {
  var _ModulesWithKnownColl;
  return (_ModulesWithKnownColl = ModulesWithKnownCollectCapability[settings.__typename]) !== null && _ModulesWithKnownColl !== void 0 ? _ModulesWithKnownColl : false;
}
function findCollectActionModuleSettings(collectable) {
  var _collectable$openActi;
  if (!collectable.openActionModules) return null;
  return (_collectable$openActi = collectable.openActionModules.find(isKnownCollectModuleSettings)) !== null && _collectable$openActi !== void 0 ? _collectable$openActi : null;
}

/* eslint-disable no-case-declarations */

/**
 * The category of Open Actions to perform on a given publication.
 */
var OpenActionKind = /*#__PURE__*/function (OpenActionKind) {
  OpenActionKind["COLLECT"] = "COLLECT";
  OpenActionKind["UNKNOWN"] = "UNKNOWN";
  return OpenActionKind;
}({});

/**
 * Execute the specified Unknown Open Action.
 */

/**
 * Execute the Collect Open Action defined by the publication.
 */

/**
 * The Open Action to perform.
 */

function resolveCollectRequestFor(publication, context) {
  var _context$action$refer, _context$action$refer2;
  var collectable = publication.__typename === 'Mirror' ? publication.mirrorOn : publication;
  var settings = findCollectActionModuleSettings(collectable);
  invariant(settings, 'No open action module settings found for publication');
  switch (settings.__typename) {
    case 'LegacyAaveFeeCollectModuleSettings':
    case 'LegacyERC4626FeeCollectModuleSettings':
    case 'LegacyFeeCollectModuleSettings':
    case 'LegacyLimitedFeeCollectModuleSettings':
    case 'LegacyLimitedTimedFeeCollectModuleSettings':
    case 'LegacyMultirecipientFeeCollectModuleSettings':
    case 'LegacyTimedFeeCollectModuleSettings':
    case 'LegacySimpleCollectModuleSettings':
      invariant(context["public"] === false, 'Legacy collect cannot be collected with just a wallet');
      return {
        kind: TransactionKind.ACT_ON_PUBLICATION,
        type: AllOpenActionType.LEGACY_COLLECT,
        publicationId: collectable.id,
        referrer: publication !== collectable ? publication.id : undefined,
        fee: {
          amount: erc20Amount({
            from: settings.amount
          }),
          contractAddress: settings.contract.address
        },
        "public": false,
        signless: context.signless,
        sponsored: context.sponsored
      };
    case 'LegacyFreeCollectModuleSettings':
      invariant(context["public"] === false, 'Legacy collect cannot be collected with just a wallet');
      return {
        kind: TransactionKind.ACT_ON_PUBLICATION,
        type: AllOpenActionType.LEGACY_COLLECT,
        publicationId: collectable.id,
        referrer: publication !== collectable ? publication.id : undefined,
        "public": false,
        signless: context.signless,
        sponsored: context.sponsored
      };
    case 'SimpleCollectOpenActionSettings':
      var amount = erc20Amount({
        from: settings.amount
      });
      return {
        kind: TransactionKind.ACT_ON_PUBLICATION,
        type: AllOpenActionType.SIMPLE_COLLECT,
        publicationId: collectable.id,
        referrers: (_context$action$refer = context.action.referrers) !== null && _context$action$refer !== void 0 ? _context$action$refer : publication !== collectable ? [publication.id] : undefined,
        fee: amount.isZero() ? undefined : {
          amount: amount,
          contractAddress: settings.contract.address
        },
        signless: context.signless,
        "public": context["public"],
        sponsored: context.sponsored
      };
    case 'MultirecipientFeeCollectOpenActionSettings':
      return {
        kind: TransactionKind.ACT_ON_PUBLICATION,
        type: AllOpenActionType.MULTIRECIPIENT_COLLECT,
        publicationId: collectable.id,
        referrers: (_context$action$refer2 = context.action.referrers) !== null && _context$action$refer2 !== void 0 ? _context$action$refer2 : publication !== collectable ? [publication.id] : undefined,
        fee: {
          amount: erc20Amount({
            from: settings.amount
          }),
          contractAddress: settings.contract.address
        },
        "public": context["public"],
        signless: context.signless,
        sponsored: context.sponsored
      };
    default:
      never("The publication ".concat(collectable.id, " is not collectable"));
  }
}
function isUnknownOpenActionModuleSettings(settings) {
  return settings.__typename === 'UnknownOpenActionModuleSettings';
}
function resolveUnknownRequestFor(publication, context) {
  var _target$openActionMod, _target$openActionMod2;
  var target = publication.__typename === 'Mirror' ? publication.mirrorOn : publication;
  var settings = (_target$openActionMod = (_target$openActionMod2 = target.openActionModules) === null || _target$openActionMod2 === void 0 ? void 0 : _target$openActionMod2.find(function (entry) {
    return isUnknownOpenActionModuleSettings(entry) && entry.contract.address === context.action.address;
  })) !== null && _target$openActionMod !== void 0 ? _target$openActionMod : never("Cannot find Open Action settings ".concat(context.action.address, " fro publication ").concat(target.id));
  return {
    kind: TransactionKind.ACT_ON_PUBLICATION,
    type: AllOpenActionType.UNKNOWN_OPEN_ACTION,
    publicationId: target.id,
    address: settings.contract.address,
    data: context.action.data,
    "public": context["public"],
    signless: context.signless,
    sponsored: context.sponsored
  };
}
function resolveOpenActionRequestFor(publication, context) {
  switch (context.action.kind) {
    case OpenActionKind.COLLECT:
      return resolveCollectRequestFor(publication, context);
    case OpenActionKind.UNKNOWN:
      return resolveUnknownRequestFor(publication, context);
  }
}

var publicationIdRegExp = /^0x[a-f0-9]{2,}-0x[a-f0-9]{2,}/i;

/**
 * @group Helpers
 */
function isPublicationId(value) {
  return publicationIdRegExp.test(value);
}

/**
 * @group Helpers
 */
function isPostPublication(publication) {
  return publication.__typename === 'Post';
}

/**
 * @group Helpers
 */
function isCommentPublication(publication) {
  return publication.__typename === 'Comment';
}

/**
 * @group Helpers
 */
function isMirrorPublication(publication) {
  return publication.__typename === 'Mirror';
}

/**
 * @group Helpers
 */
function isQuotePublication(publication) {
  return publication.__typename === 'Quote';
}

/**
 * @group Helpers
 */
function isPrimaryPublication(publication) {
  return isCommentPublication(publication) || isPostPublication(publication) || isQuotePublication(publication);
}

function resolveTokenAllowanceRequestForCollect(publication, limit) {
  var module = findCollectActionModuleSettings(publication);
  invariant(module, "Publication ".concat(publication.id, " has no collect module"));
  switch (module.__typename) {
    case 'LegacyAaveFeeCollectModuleSettings':
    case 'LegacyERC4626FeeCollectModuleSettings':
    case 'LegacyFeeCollectModuleSettings':
    case 'LegacyLimitedFeeCollectModuleSettings':
    case 'LegacyLimitedTimedFeeCollectModuleSettings':
    case 'LegacyMultirecipientFeeCollectModuleSettings':
    case 'LegacySimpleCollectModuleSettings':
    case 'LegacyTimedFeeCollectModuleSettings':
    case 'MultirecipientFeeCollectOpenActionSettings':
    case 'SimpleCollectOpenActionSettings':
      return {
        kind: TransactionKind.APPROVE_MODULE,
        amount: erc20Amount({
          from: module.amount
        }),
        limit: limit,
        spender: module.contract.address
      };
    default:
      never("Unsupported collect module type ".concat(module.__typename));
  }
}
function resolveTokenAllowanceRequestForFollow(profile, limit) {
  invariant(profile.followModule, "Profile ".concat(profile.id, " has no follow module"));
  switch (profile.followModule.__typename) {
    case 'FeeFollowModuleSettings':
      return {
        kind: TransactionKind.APPROVE_MODULE,
        amount: erc20Amount({
          from: profile.followModule.amount
        }),
        limit: limit,
        spender: profile.followModule.contract.address
      };
    default:
      never("Unsupported follow module type ".concat(profile.followModule.__typename));
  }
}
function resolveTokenAllowanceRequest(item, limit) {
  switch (item.__typename) {
    case 'Mirror':
      return resolveTokenAllowanceRequestForCollect(item.mirrorOn, limit);
    case 'Comment':
    case 'Post':
    case 'Quote':
      return resolveTokenAllowanceRequestForCollect(item, limit);
    case 'Profile':
      return resolveTokenAllowanceRequestForFollow(item, limit);
    default:
      assertNever(item);
  }
}

/**
 * @deprecated not longer in use - removal slated for stable 2.x release
 */

/**
 * Resolve API {@link FollowModule} to more user friendly {@link FollowPolicy}.
 *
 * @param args - The {@link Profile} to resolve {@link FollowPolicy} from
 * @returns {@link FollowPolicy}
 */
function resolveFollowPolicy(_ref) {
  var followModule = _ref.followModule;
  if (followModule === null) {
    return {
      type: FollowPolicyType.ANYONE
    };
  }
  switch (followModule.__typename) {
    case 'FeeFollowModuleSettings':
      return {
        type: FollowPolicyType.CHARGE,
        amount: erc20Amount({
          from: followModule.amount
        }),
        recipient: followModule.recipient,
        contractAddress: followModule.contract.address,
        chainId: followModule.contract.chainId
      };
    case 'RevertFollowModuleSettings':
      return {
        type: FollowPolicyType.NO_ONE,
        contractAddress: followModule.contract.address,
        chainId: followModule.contract.chainId
      };
    case 'UnknownFollowModuleSettings':
      return {
        type: FollowPolicyType.UNKNOWN,
        contractAddress: followModule.contract.address,
        chainId: followModule.contract.chainId
      };
  }
}

/**
 * @internal
 */
var ContentInsightType = /*#__PURE__*/function (ContentInsightType) {
  ContentInsightType["SNAPSHOT_POLL"] = "SNAPSHOT_POLL";
  ContentInsightType["UNDETERMINED"] = "UNDETERMINED";
  return ContentInsightType;
}({});

/**
 * Opaque data structure representing a Snapshot poll details.
 */

/**
 * Opaque data structure representing
 */

/**
 * Opaque data structure representing insights on the publication metadata textual content
 */

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var RequestsQueue = /*#__PURE__*/function () {
  function RequestsQueue() {
    _classCallCheck(this, RequestsQueue);
    _defineProperty(this, "requests", new Map());
  }
  _createClass(RequestsQueue, [{
    key: "enqueue",
    value: function enqueue(request) {
      this.requests.set(request.operation, request);
    }
  }, {
    key: "dequeue",
    value: function dequeue(operation) {
      this.requests["delete"](operation);
    }
  }, {
    key: "consume",
    value: function consume() {
      var _iterator = _createForOfIteratorHelper(this.requests.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var request = _step.value;
          request.forward(request.operation).subscribe(request.observer);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }]);
  return RequestsQueue;
}();
var RefreshTokensLink = /*#__PURE__*/function (_ApolloLink) {
  _inherits(RefreshTokensLink, _ApolloLink);
  var _super = _createSuper(RefreshTokensLink);
  function RefreshTokensLink(accessTokenStorage) {
    var _this;
    _classCallCheck(this, RefreshTokensLink);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "refreshing", false);
    _defineProperty(_assertThisInitialized(_this), "queue", new RequestsQueue());
    _this.accessTokenStorage = accessTokenStorage;
    return _this;
  }
  _createClass(RefreshTokensLink, [{
    key: "request",
    value: function request(operation, forward) {
      var _this2 = this;
      invariant(forward, "".concat(RefreshTokensLink.name, " is a non-terminating link and should not be the last in the composed chain"));
      return new Observable(function (observer) {
        // this if is extremely difficult to test with standard Apollo Client mocks
        if (_this2.refreshing) {
          _this2.queue.enqueue({
            operation: operation,
            forward: forward,
            observer: observer
          });
          return function () {
            _this2.queue.dequeue(operation);
          };
        }
        var subscription = forward(operation).subscribe({
          next: function () {
            var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(result) {
              var refresh;
              return _regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (!_this2.refreshing) {
                      _context.next = 3;
                      break;
                    }
                    _this2.queue.enqueue({
                      operation: operation,
                      forward: forward,
                      observer: observer
                    });
                    return _context.abrupt("return");
                  case 3:
                    if (!graphQLResultHasUnauthenticatedError(result)) {
                      _context.next = 13;
                      break;
                    }
                    if (_this2.refreshing) {
                      _context.next = 12;
                      break;
                    }
                    _this2.refreshing = true;
                    _context.next = 8;
                    return _this2.accessTokenStorage.refreshToken();
                  case 8:
                    refresh = _context.sent;
                    _this2.refreshing = false;
                    if (refresh.isFailure()) {
                      observer.next(result);
                    } else {
                      forward(operation).subscribe(observer);
                    }
                    _this2.queue.consume();
                  case 12:
                    return _context.abrupt("return");
                  case 13:
                    observer.next(result);
                  case 14:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            function next(_x) {
              return _next.apply(this, arguments);
            }
            return next;
          }(),
          error: function error(_error) {
            observer.error(_error);
          },
          complete: function complete() {
            // if refreshing, do not close the observer
            if (_this2.refreshing) {
              return;
            }
            observer.complete();
          }
        });
        return function () {
          subscription.unsubscribe();
        };
      });
    }
  }]);
  return RefreshTokensLink;
}(ApolloLink);
function createAuthLink(accessTokenStorage) {
  var tokenRefreshLink = new RefreshTokensLink(accessTokenStorage);
  var authHeaderLink = setContext(function (_, prevContext) {
    var token = accessTokenStorage.getAccessToken();
    if (token) {
      return _objectSpread2(_objectSpread2({}, prevContext), {}, {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        headers: _objectSpread2({
          authorization: "Bearer ".concat(token)
        }, 'headers' in prevContext && prevContext.headers)
      });
    }
    return prevContext;
  });
  return from([tokenRefreshLink, authHeaderLink]);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

var backupFetch = maybe(function () {
  return fetch;
});
function wrapFetch(logger, supportedVersion, fetch) {
  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var response,
      apiVersion,
      _apiVersion$split,
      _apiVersion$split2,
      apiMajor,
      apiMinor,
      _supportedVersion$spl,
      _supportedVersion$spl2,
      clientMajor,
      clientMinor,
      _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return fetch.apply(void 0, _args);
        case 2:
          response = _context.sent;
          if (!(response.status === 200)) {
            _context.next = 17;
            break;
          }
          apiVersion = response.headers.get('x-api-version');
          if (!apiVersion) {
            _context.next = 17;
            break;
          }
          if (!(apiVersion < supportedVersion)) {
            _context.next = 9;
            break;
          }
          logger.warn("The Lens API ".concat(apiVersion, " is outside of the Lens SDK support range ^").concat(supportedVersion));
          return _context.abrupt("return", response);
        case 9:
          _apiVersion$split = apiVersion.split('.'), _apiVersion$split2 = _slicedToArray(_apiVersion$split, 2), apiMajor = _apiVersion$split2[0], apiMinor = _apiVersion$split2[1];
          _supportedVersion$spl = supportedVersion.split('.'), _supportedVersion$spl2 = _slicedToArray(_supportedVersion$spl, 2), clientMajor = _supportedVersion$spl2[0], clientMinor = _supportedVersion$spl2[1];
          if (!(apiMajor && clientMajor && apiMajor > clientMajor)) {
            _context.next = 14;
            break;
          }
          logger.warn("The Lens API ".concat(apiVersion, " is NOT supported by the Lens SDK support range ^").concat(supportedVersion, ". Update your Lens SDK client to the latest version."));
          return _context.abrupt("return", response);
        case 14:
          if (!(apiMinor && clientMinor && apiMinor > clientMinor)) {
            _context.next = 17;
            break;
          }
          logger.info("The Lens API ".concat(apiVersion, " is ahead of the Lens SDK support range ^").concat(supportedVersion, ". Check for a new version of the Lens SDK client, if available."));
          return _context.abrupt("return", response);
        case 17:
          return _context.abrupt("return", response);
        case 18:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
}
function createLensLink(_ref2) {
  var _ref3, _ref4;
  var preferredFetch = _ref2.fetch,
    logger = _ref2.logger,
    supportedVersion = _ref2.supportedVersion,
    uri = _ref2.uri;
  // see https://github.com/apollographql/apollo-client/blob/4bf773f64b78f15419f07676f434fa33e058404e/src/link/http/createHttpLink.ts#L160-L165
  var currentFetch = (_ref3 = (_ref4 = preferredFetch !== null && preferredFetch !== void 0 ? preferredFetch : maybe(function () {
    return fetch;
  })) !== null && _ref4 !== void 0 ? _ref4 : backupFetch) !== null && _ref3 !== void 0 ? _ref3 : never();
  return new HttpLink({
    uri: uri,
    fetch: wrapFetch(logger, supportedVersion, currentFetch)
  });
}
function createSnapshotLink(_ref5) {
  var uri = _ref5.uri;
  return new HttpLink({
    uri: uri
  });
}

var snapshotRegExp = /https:\/\/snapshot\.org\/#\/([^/]+)\/proposal\/(0x[a-fA-F0-9]+)/;
var snapshotDemoRegExp = /https:\/\/demo\.snapshot\.org\/#\/([^/]+)\/proposal\/(0x[a-fA-F0-9]+)/;
function snapshotUrlMatcher(pattern, url) {
  var _pattern$exec;
  var _ref = (_pattern$exec = pattern.exec(url)) !== null && _pattern$exec !== void 0 ? _pattern$exec : [],
    _ref2 = _slicedToArray(_ref, 3),
    spaceId = _ref2[1],
    proposalId = _ref2[2];
  if (spaceId && proposalId) {
    return {
      type: ContentInsightType.SNAPSHOT_POLL,
      spaceId: spaceId,
      proposalId: proposalId,
      url: url
    };
  }
  return null;
}
function snapshotPoll(url) {
  return snapshotUrlMatcher(snapshotRegExp, url);
}
function demoSnapshotPoll(url) {
  return snapshotUrlMatcher(snapshotDemoRegExp, url);
}

var sessionVar = makeVar(null);
function getSessionData() {
  return sessionVar();
}
function useSessionDataVar() {
  return useReactiveVar(sessionVar);
}
function resetSession() {
  sessionVar(null);
}
function updateSessionData(session) {
  sessionVar(session);
}

function createLensApolloClient(_ref) {
  var accessTokenStorage = _ref.accessTokenStorage,
    uri = _ref.uri,
    logger = _ref.logger,
    pollingInterval = _ref.pollingInterval,
    queryParams = _ref.queryParams;
  var authLink = createAuthLink(accessTokenStorage);
  var httpLink = createLensLink({
    uri: uri,
    logger: logger,
    supportedVersion: LENS_API_MINIMAL_SUPPORTED_VERSION
  });
  return new SafeApolloClient({
    connectToDevTools: true,
    cache: createLensCache(queryParams),
    link: from([authLink, httpLink]),
    pollingInterval: pollingInterval,
    version: LENS_API_MINIMAL_SUPPORTED_VERSION
  });
}
function createAuthApolloClient(_ref2) {
  var uri = _ref2.uri,
    logger = _ref2.logger;
  return new SafeApolloClient({
    cache: createLensCache(),
    link: createLensLink({
      uri: uri,
      logger: logger,
      supportedVersion: LENS_API_MINIMAL_SUPPORTED_VERSION
    }),
    version: LENS_API_MINIMAL_SUPPORTED_VERSION
  });
}
function createSnapshotApolloClient(_ref3) {
  var uri = _ref3.uri;
  return new SafeApolloClient({
    cache: createSnapshotCache(),
    link: createSnapshotLink({
      uri: uri
    })
  });
}

/**
 * @experimental
 */
var SnapshotVotingSystem = /*#__PURE__*/function (SnapshotVotingSystem) {
  SnapshotVotingSystem["SINGLE_CHOICE"] = "single-choice";
  SnapshotVotingSystem["APPROVAL"] = "approval";
  SnapshotVotingSystem["QUADRATIC"] = "quadratic";
  SnapshotVotingSystem["RANKED_CHOICE"] = "ranked-choice";
  SnapshotVotingSystem["WEIGHTED"] = "weighted";
  SnapshotVotingSystem["BASIC"] = "basic";
  return SnapshotVotingSystem;
}({});

export { ContentInsightType, OpenActionKind, SnapshotVotingSystem, chainType, createAuthApolloClient, createLensApolloClient, createSnapshotApolloClient, demoSnapshotPoll, erc20Amount, getSessionData, isCommentPublication, isMirrorPublication, isPostPublication, isPrimaryPublication, isPublicationId, isQuotePublication, isValidHandle, omitTypename, resetSession, resolveFollowPolicy, resolveOpenActionRequestFor, resolveTokenAllowanceRequest, resolveTokenAllowanceRequestForCollect, resolveTokenAllowanceRequestForFollow, snapshotPoll, updateSessionData, useSessionDataVar };
