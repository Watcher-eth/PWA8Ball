"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTransactionButtonCore = void 0;
const react_1 = require("react");
const wait_for_tx_receipt_js_1 = require("../../../../transaction/actions/wait-for-tx-receipt.js");
const json_js_1 = require("../../../../utils/json.js");
const useSendTransaction_js_1 = require("../../../web/hooks/useSendTransaction.js");
const wallet_hooks_js_1 = require("../wallets/wallet-hooks.js");
function useTransactionButtonCore(props) {
    const { transaction, onTransactionSent, onTransactionConfirmed, onError, onClick, gasless, payModal, } = props;
    const account = (0, wallet_hooks_js_1.useActiveAccount)();
    const [isPending, setIsPending] = (0, react_1.useState)(false);
    const sendTransaction = (0, useSendTransaction_js_1.useSendTransaction)({
        gasless,
        payModal,
    });
    const handleClick = async () => {
        if (onClick) {
            onClick();
        }
        try {
            setIsPending(true);
            const resolvedTx = await transaction();
            const result = await sendTransaction.mutateAsync(resolvedTx);
            if (onTransactionSent) {
                onTransactionSent(result);
            }
            if (onTransactionConfirmed) {
                const receipt = await (0, wait_for_tx_receipt_js_1.waitForReceipt)(result);
                if (receipt.status === "reverted") {
                    throw new Error(`Execution reverted: ${(0, json_js_1.stringify)(receipt, null, 2)}`);
                }
                onTransactionConfirmed(receipt);
            }
        }
        catch (error) {
            if (onError) {
                onError(error);
            }
        }
        finally {
            setIsPending(false);
        }
    };
    return {
        account,
        handleClick,
        isPending,
    };
}
exports.useTransactionButtonCore = useTransactionButtonCore;
//# sourceMappingURL=button-core.js.map